package com.hackamaroo.hw2;

import java.util.*;

public class Collision {
	private int minDist; 
	private double distanceAY; 
	private double closeness; 
	private double score; 
	
	public Collision(){
		minDist = -1; 
		distanceAY = -1;
		closeness = -1; 
		score = 0; 
	}
	
	public boolean checkCollision(Point first, Point last, int xc, int yc, int rc){
		//TO DO
		List<Point> linePoints = new ArrayList<Point>();
		int x0 = (int)first.getX();
		int x1 = (int)last.getX(); 
		int y0 = (int)first.getY(); 
		int y1 = (int)last.getY(); 
	    double deltax = x1 - x0;
	    double deltay = y1 - y0;
	    double error = 0;
	    if (deltax -0 < 0.000000001){
	    	deltax = 0.00000000001; 
	    }
	    double deltaerr = Math.abs(deltay / deltax);    // Assume deltax != 0 (line is not vertical),
	           // note that this division needs to be done in a way that preserves the fractional part
	    int y = y0;
	    for (int x = x0; x <= x1; x++){
	         linePoints.add(new Point(x, y, 0, 0, true)); // Default values for params
	         error = error + deltaerr;
	         if (error >= 0.5){ 
	             y = y + 1;
	             error = error - 1.0;
	         }
	    }
	    // Calculate the minimum distance
	    for (int i = 0; i < linePoints.size(); i++) {
	    	int px = (int) linePoints.get(i).getX();
    		int py = (int) linePoints.get(i).getY();
	    	if (i == 0) {
	    		minDist = (int) distance(px, py, xc, yc);
	    	}
	    	else {
	    		int temp = (int) distance(px, py, xc, yc);
	    		if (temp < minDist) {
	    			minDist = temp;
	    		}
	    	}
	    }
	    
		return (minDist <= rc);
	}
	
	public boolean checkCollisionAY(Point first, Point last, int xc, int yc, int rc){
		double slope = (last.getY() - first.getY()) / (last.getX() - first.getX()); 
		double b = last.getY() - slope * last.getX(); 
		distanceAY =  (Math.abs(slope*xc - yc + b) / Math.sqrt(slope*slope + 1));
		closeness = distance(last.getX(), last.getY(), xc, yc); 
		//be warned that this closeness can be very skewed b/c android doesn't sample EVERY point
		
		if (distanceAY <= rc && closeness < 2*rc){
			score = (1.0 / (distanceAY + (closeness / 
					distance(last.getX(), last.getY(), first.getX(), first.getY())))); 
			//return true; 
		}
		score = 0; 
		//return false; 
		
		return segment_circle(first, last,  xc,  yc, rc); 

	}
	
	public double distance(double d, double e, double f, double g){
		return ( Math.sqrt((d-f)*(d-f) + (e - g)*(e-g)));
	}
	
	public double getScore(){
		return score; 
	}
	
	public double getCloseness(){
		return closeness; 
	}
	
	public int getMinDist(){
		return minDist; 
	}
	
	
    public Point closest_point_on_seg(Point a, Point b, double xc, double yc){
    	Point cPoint = new Point (xc, yc);
        Vector seg_v = new Vector(a, b);
        Vector pt_v = new Vector(a, cPoint);
        if (a.distance(b) <= 0){
            //"Invalid segment length"
        }
        Vector seg_v_unit = seg_v.normalize();
        double proj = pt_v.dot(seg_v_unit);
        if (proj <= 0){
            return a;
        }
        if (proj >= seg_v.length()){
            return b;
        }
        Vector proj_v = seg_v_unit.times( proj);
        Point closest = proj_v.add(a); 
        return closest;
    }

    public boolean segment_circle(Point a, Point b, double xc, double yc, double circ_rad){
        Point closest = closest_point_on_seg(a, b, xc, yc);
        Point circ_pos = new Point(xc, yc);
        closeness = closest.distance(circ_pos);
        //Vector v = new Vector(circ_pos, closest);
        //offset = v / dist_v * (circ_rad - dist_v);
        if (closeness > circ_rad){
            return false;
        }
        if (closeness <= 0){
            //"Circle's center is exactly on segment"
        	return true; 
        }
        
    }
    


}
}
