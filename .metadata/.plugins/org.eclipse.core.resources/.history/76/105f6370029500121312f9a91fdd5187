package com.hackamaroo.hw2;

import java.util.*;

public class Collision {
	private int minDist; 
	private double distanceAY; 
	private double closeness; 
	private double score; 
	
	public Collision(){
		minDist = -1; 
		distanceAY = -1;
		closeness = -1; 
		score = 0; 
	}
	
	public boolean checkCollision(Point first, Point last, int xc, int yc, int rc){
		//TO DO
		List<Point> linePoints = new ArrayList<Point>();
		int x0 = (int)first.getX();
		int x1 = (int)last.getX(); 
		int y0 = (int)first.getY(); 
		int y1 = (int)last.getY(); 
	    double deltax = x1 - x0;
	    double deltay = y1 - y0;
	    double error = 0;
	    if (deltax -0 < 0.000000001){
	    	deltax = 0.00000000001; 
	    }
	    double deltaerr = Math.abs(deltay / deltax);    // Assume deltax != 0 (line is not vertical),
	           // note that this division needs to be done in a way that preserves the fractional part
	    int y = y0;
	    for (int x = x0; x <= x1; x++){
	         linePoints.add(new Point(x, y, 0, 0, true)); // Default values for params
	         error = error + deltaerr;
	         if (error >= 0.5){ 
	             y = y + 1;
	             error = error - 1.0;
	         }
	    }
	    // Calculate the minimum distance
	    for (int i = 0; i < linePoints.size(); i++) {
	    	int px = (int) linePoints.get(i).getX();
    		int py = (int) linePoints.get(i).getY();
	    	if (i == 0) {
	    		minDist = (int) distance(px, py, xc, yc);
	    	}
	    	else {
	    		int temp = (int) distance(px, py, xc, yc);
	    		if (temp < minDist) {
	    			minDist = temp;
	    		}
	    	}
	    }
	    
		return (minDist <= rc);
	}
	
	public boolean checkCollisionAY(Point first, Point last, int xc, int yc, int rc){
		double slope = (last.getY() - first.getY()) / (last.getX() - first.getX()); 
		double b = last.getY() - slope * last.getX(); 
		distanceAY =  (Math.abs(slope*xc - yc + b) / Math.sqrt(slope*slope + 1));
		closeness = distance(last.getX(), last.getY(), xc, yc); 
		//be warned that this closeness can be very skewed b/c android doesn't sample EVERY point
		
		if (distanceAY <= rc && closeness < 2*rc){
			score = (1.0 / (distanceAY + (closeness / 
					distance(last.getX(), last.getY(), first.getX(), first.getY())))); 
			return true; 
		}
		score = 0; 
		return false; 

	}
	
	public double distance(double d, double e, double f, double g){
		return ( Math.sqrt((d-f)*(d-f) + (e - g)*(e-g)));
	}
	
	public double getScore(){
		return score; 
	}
	
	public double getCloseness(){
		return closeness; 
	}
	
	public int getMinDist(){
		return minDist; 
	}
	
	
    public Point closest_point_on_seg(Point a, Point b, float xc, float yc){
    	Point cPoint = new Point (xc, yc);
        Vector seg_v = new Vector(a, b);
        Vector pt_v = new Vector(a, cPoint);
        if (a.distance(b) <= 0){
            //"Invalid segment length"
        }
        Point seg_v_unit = new Point(seg_v.getX() / a.distance(b), seg_v.getY() / a.distance(b));
        proj = pt_v.dot(seg_v_unit)
        if proj <= 0:
            return seg_a.copy()
        if proj >= seg_v.len():
            return seg_b.copy()
        proj_v = seg_v_unit * proj
        closest = proj_v + seg_a
        return closest
    }

    def segment_circle(seg_a, seg_b, circ_pos, circ_rad):
        closest = closest_point_on_seg(seg_a, seg_b, circ_pos)
        dist_v = circ_pos - closest
        if dist_v.len() > circ_rad:
            return vec(0, 0)
        if dist_v.len() <= 0:
            raise ValueError, "Circle's center is exactly on segment"
        offset = dist_v / dist_v.len() * (circ_rad - dist_v.len())
        return offset
    


	
}
